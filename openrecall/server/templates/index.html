{% extends "layout.html" %}

{% block title %}MyRecall{% endblock %}

{% block toolbar_center %}
<div class="form-group">
  <label for="start_time">Start Time</label>
  <input type="datetime-local" id="start_time" name="start_time">
</div>
<div class="form-group">
  <label for="end_time">End Time</label>
  <input type="datetime-local" id="end_time" name="end_time">
</div>
{% endblock %}

{% block extra_head %}
<style>
  /* Form groups for toolbar */
  .form-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  
  .form-group label {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
  }
  
  .form-group input {
    padding: 8px 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    font-size: 14px;
    font-family: var(--font-stack);
    background: var(--bg-body);
    color: var(--text-primary);
  }
  
  .form-group input:focus {
    outline: none;
    border-color: var(--accent-color);
  }

  /* Spinner Animation */
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  .spinner {
    display: inline-block;
    width: 14px;
    height: 14px;
    border: 2.5px solid rgba(0, 122, 255, 0.2);
    border-top-color: var(--accent-color);
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
    flex-shrink: 0;
  }
  
  /* Memory Grid Layout */
  .memory-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    gap: 24px;
    padding: 24px 0;
  }
  
  /* Memory Card */
  .memory-card {
    background: var(--bg-card);
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
    transition: transform 0.2s, box-shadow 0.2s;
    content-visibility: auto;
    contain-intrinsic-size: 420px 360px;
  }
  
  .memory-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
  }
  
  /* Card Header */
  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
  }
  
  .card-app {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-primary);
  }
  
  .card-time {
    font-size: 0.75rem;
    color: var(--text-secondary);
    font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
  }
  
  /* Card Image */
  .card-image {
    width: 100%;
    height: auto;
    display: block;
    cursor: pointer;
  }
  
  /* Card Footer with Status */
  .card-footer {
    padding: 12px 16px;
    border-top: 1px solid var(--border-color);
    background: #F9F9FB;
    min-height: 60px;
    display: flex;
    align-items: flex-start;
    padding-top: 14px;
    transition: all 0.3s ease;
  }
  
  .status-processing {
    display: flex;
    align-items: center;
    color: var(--text-secondary);
  }
  
  .status-processing span {
    margin-left: 8px;
    font-size: 0.85rem;
  }
  
  .ai-description {
    font-size: 0.85rem;
    color: #333;
    line-height: 1.4;
    max-height: 3em;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    transition: max-height 0.3s ease, -webkit-line-clamp 0.3s ease;
  }
  
  .memory-card:hover .ai-description {
    max-height: none;
    -webkit-line-clamp: unset;
    overflow: visible;
  }
  
  .ai-icon {
    margin-right: 6px;
  }
  
  .fallback-text {
    font-size: 0.8rem;
    color: var(--text-secondary);
    font-style: italic;
  }
  
  /* Modal for full image view */
  .modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.9);
    z-index: 1000;
    padding: 16px;
    box-sizing: border-box;
  }
  
  .modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  .modal-content {
    width: calc(100vw - 32px);
    height: calc(100vh - 32px);
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
  }
  
  .modal-content img {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    object-fit: contain;
    border-radius: 8px;
  }
  
  .modal-close {
    position: absolute;
    top: 16px;
    right: 16px;
    color: white;
    font-size: 32px;
    cursor: pointer;
    z-index: 1001;
  }

  .modal-meta {
    position: absolute;
    top: 16px;
    left: 16px;
    max-width: calc(100vw - 160px);
    padding: 10px 12px;
    border-radius: 10px;
    background: rgba(0, 0, 0, 0.35);
    color: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    z-index: 1001;
  }

  .modal-meta-line {
    font-size: 12px;
    font-weight: 600;
    line-height: 1.25;
    opacity: 0.92;
    margin-top: 6px;
  }

  .modal-meta-line:first-child {
    margin-top: 0;
  }

  .modal-nav {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 44px;
    height: 44px;
    border-radius: 999px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    background: rgba(0, 0, 0, 0.35);
    color: white;
    font-size: 22px;
    line-height: 1;
    cursor: pointer;
    z-index: 1001;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
  }

  .modal-nav:hover {
    background: rgba(0, 0, 0, 0.5);
  }

  .modal-nav.prev {
    left: 16px;
  }

  .modal-nav.next {
    right: 16px;
  }
  
  .empty-state {
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 40px;
    text-align: center;
    color: var(--text-secondary);
  }

  /* Stats Bar */
  .stats-bar {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    padding: 12px 20px;
    background: var(--bg-card);
    border-radius: 12px;
    border: 1px solid var(--border-color);
    width: fit-content;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  }
  
  .stat-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
    color: var(--text-secondary);
  }
  
  .stat-value {
    font-weight: 600;
    color: var(--text-primary);
    background: rgba(0, 0, 0, 0.05);
    padding: 2px 8px;
    border-radius: 6px;
    font-size: 0.85rem;
  }

  .status-pending {
    display: flex;
    align-items: center;
    color: var(--text-secondary);
  }
  
  .status-pending span {
    margin-left: 8px;
    font-size: 0.85rem;
  }

  [x-cloak] {
    display: none !important;
  }
</style>

<script id="initialEntriesData" type="application/json">{{ entries | tojson | safe }}</script>
<script id="initialConfigData" type="application/json">{{ {'show_ai_description': settings.show_ai_description} | tojson | safe }}</script>
<script>
  (() => {
    const entriesEl = document.getElementById("initialEntriesData");
    const configEl = document.getElementById("initialConfigData");
    try {
      window.initialEntries = JSON.parse(entriesEl?.textContent || "[]");
    } catch (_e) {
      window.initialEntries = [];
    }
    try {
      window.initialConfig = JSON.parse(configEl?.textContent || "{}");
    } catch (_e) {
      window.initialConfig = { show_ai_description: false };
    }
  })();
</script>
{% endblock %}

{% block content %}
<div x-data="memoryGrid()" x-init="init()" x-cloak>
  <template x-if="entries.length > 0">
    <div>
      <div class="stats-bar">
        <div class="stat-item">
          <span>Completed</span>
          <span class="stat-value" x-text="stats().completed"></span>
        </div>
        <div class="stat-item">
          <span>Processing</span>
          <span class="stat-value" x-text="stats().processing"></span>
        </div>
        <div class="stat-item">
          <span>Pending</span>
          <span class="stat-value" x-text="stats().pending"></span>
        </div>
      </div>

      <div class="memory-grid">
        <template x-for="(entry, i) in entries" :key="entry.id ?? (entry.timestamp + '-' + i)">
          <article class="memory-card">
            <div class="card-header">
              <span class="card-app" x-text="entry.app || 'Unknown'"></span>
              <span class="card-time" x-text="formatTime(entry.timestamp)"></span>
            </div>

            <img
              :src="imageSrc(entry)"
              alt="Screenshot"
              class="card-image"
              :loading="i < 8 ? 'eager' : 'lazy'"
              decoding="async"
              :fetchpriority="i < 2 ? 'high' : 'auto'"
              @click="openAt(i)"
            >

            <div class="card-footer">
              <template x-if="entry.status === 'PROCESSING'">
                <div class="status-processing">
                  <div class="spinner"></div>
                  <span>Processing...</span>
                </div>
              </template>
              <template x-if="entry.status === 'PENDING' || entry.status === 'CANCELLED'">
                <div class="status-pending">
                  <span class="ai-icon">⏳</span>
                  <span>Pending...</span>
                </div>
              </template>
              <template x-if="entry.status !== 'PROCESSING' && entry.status !== 'PENDING' && entry.status !== 'CANCELLED' && config.show_ai_description && entry.description">
                <div class="ai-description">
                  <span class="ai-icon">✨</span><span class="ai-insight-text" x-text="entry.description"></span>
                </div>
              </template>
              <template x-if="entry.status !== 'PROCESSING' && entry.status !== 'PENDING' && entry.status !== 'CANCELLED' && !(config.show_ai_description && entry.description)">
                <span class="fallback-text">Image captured</span>
              </template>
            </div>
          </article>
        </template>
      </div>

      <div id="imageModal" class="modal" :class="{ 'active': isOpen() }" @click.self="closeModal()">
        <button class="modal-nav prev" type="button" aria-label="Previous image" @click="prev()">‹</button>
        <button class="modal-nav next" type="button" aria-label="Next image" @click="next()">›</button>
        <div class="modal-meta">
          <div class="modal-meta-line" x-text="selectedIndex !== null ? `${selectedIndex + 1} / ${entries.length}` : ''"></div>
          <div class="modal-meta-line" x-text="selectedEntry ? (selectedEntry.app || 'Unknown') : ''"></div>
          <div class="modal-meta-line" x-text="selectedEntry ? formatTime(selectedEntry.timestamp) : ''"></div>
        </div>
        <span class="modal-close" role="button" aria-label="Close" @click="closeModal()">&times;</span>
        <div class="modal-content">
          <img id="modalImage" alt="Screenshot" :src="selectedEntry ? imageSrc(selectedEntry) : ''">
        </div>
      </div>
    </div>
  </template>

  <template x-if="entries.length === 0">
    <div class="empty-state">
      Nothing recorded yet, wait a few seconds.
    </div>
  </template>
</div>
{% endblock %}

{% block extra_body %}
<script>
  function memoryGrid() {
    return {
      entries: window.initialEntries || [],
      config: window.initialConfig || { show_ai_description: false },
      lastCheck: 0,
      selectedIndex: null,

      get selectedEntry() {
        if (this.selectedIndex === null) return null;
        return this.entries[this.selectedIndex] || null;
      },

      init() {
        this.lastCheck = this.entries.reduce((maxTs, entry) => {
          const ts = Number(entry?.timestamp) || 0;
          return ts > maxTs ? ts : maxTs;
        }, 0);

        window.addEventListener("openrecall-config-changed", () => {
          this.refreshRecent();
          setTimeout(() => this.refreshRecent(), 500);
        });

        window.addEventListener("keydown", (e) => {
          if (!this.isOpen()) return;
          if (e.key === "Escape") this.closeModal();
          if (e.key === "ArrowLeft") this.prev();
          if (e.key === "ArrowRight") this.next();
        });

        setInterval(() => {
          this.checkNew();
          this.refreshRecent();
        }, 5000);
      },

      async checkNew() {
        try {
          const res = await fetch(`/api/memories/latest?since=${this.lastCheck}`);
          if (!res.ok) return;
          const newItems = await res.json();
          if (!Array.isArray(newItems) || newItems.length === 0) return;

          const existingKeys = new Set(
            this.entries.map((e, idx) => (e?.id ?? `${e?.timestamp}-${idx}`)).filter((v) => v !== undefined)
          );
          const uniqueItems = newItems.filter((e, idx) => {
            const key = e?.id ?? `${e?.timestamp}-${idx}`;
            return !existingKeys.has(key);
          });
          if (uniqueItems.length === 0) return;

          if (this.selectedIndex !== null) {
            this.selectedIndex += uniqueItems.length;
          }
          this.entries.unshift(...uniqueItems);

          const maxNewTs = uniqueItems.reduce((maxTs, entry) => {
            const ts = Number(entry?.timestamp) || 0;
            return ts > maxTs ? ts : maxTs;
          }, 0);
          if (maxNewTs > this.lastCheck) this.lastCheck = maxNewTs;
        } catch (_e) {
          return;
        }
      },

      async refreshRecent() {
        try {
          const res = await fetch(`/api/memories/recent?limit=200`);
          if (!res.ok) return;
          const recent = await res.json();
          if (!Array.isArray(recent) || recent.length === 0) return;

          const indexById = new Map();
          for (let i = 0; i < this.entries.length; i += 1) {
            const id = this.entries[i]?.id;
            if (id === undefined || id === null) continue;
            indexById.set(id, i);
          }

          const toPrepend = [];
          for (const entry of recent) {
            const id = entry?.id;
            if (id === undefined || id === null) continue;
            const idx = indexById.get(id);
            if (idx === undefined) {
              toPrepend.push(entry);
              continue;
            }

            const existing = this.entries[idx];
            this.entries[idx] = { ...existing, ...entry };
          }

          if (toPrepend.length > 0) {
            const existingIds = new Set(indexById.keys());
            const unique = toPrepend.filter((e) => !existingIds.has(e.id));
            if (unique.length > 0) {
              if (this.selectedIndex !== null) {
                this.selectedIndex += unique.length;
              }
              this.entries.unshift(...unique);
            }
          }

          const maxRecentTs = recent.reduce((maxTs, entry) => {
            const ts = Number(entry?.timestamp) || 0;
            return ts > maxTs ? ts : maxTs;
          }, 0);
          if (maxRecentTs > this.lastCheck) this.lastCheck = maxRecentTs;
        } catch (_e) {
          return;
        }
      },

      stats() {
        const out = { completed: 0, pending: 0, processing: 0 };
        for (const entry of this.entries) {
          const status = entry?.status;
          if (status === "COMPLETED") out.completed += 1;
          else if (status === "PENDING" || status === "CANCELLED") out.pending += 1;
          else if (status === "PROCESSING") out.processing += 1;
        }
        return out;
      },

      formatTime(ts) {
        const n = Number(ts) || 0;
        const d = new Date(n * 1000);
        const pad = (v) => String(v).padStart(2, "0");
        return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      },

      imageSrc(entry) {
        const filename = entry?.filename || `${entry?.timestamp}.png`;
        return `/screenshots/${filename}`;
      },

      isOpen() {
        return this.selectedIndex !== null;
      },

      openAt(i) {
        const idx = Number(i);
        if (!Number.isFinite(idx)) return;
        if (idx < 0 || idx >= this.entries.length) return;
        this.selectedIndex = idx;
      },

      closeModal() {
        this.selectedIndex = null;
      },

      prev() {
        if (this.selectedIndex === null) return;
        const n = this.entries.length;
        if (!n) return;
        this.selectedIndex = (this.selectedIndex - 1 + n) % n;
      },

      next() {
        if (this.selectedIndex === null) return;
        const n = this.entries.length;
        if (!n) return;
        this.selectedIndex = (this.selectedIndex + 1) % n;
      },
    };
  }
</script>
{% endblock %}
